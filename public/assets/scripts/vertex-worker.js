import{SimplexNoise}from"https://unpkg.com/simplex-noise-esm@2.5.0-esm.0/dist-esm/simplex-noise.js";let simplex=null;const VERTICES_PER_SQUARE=6;function reconstructFunction(e){let s=(e=(e=(e=e.replace(/\S*__WEBPACK_IMPORTED_MODULE_\d+__./g,"")).replace("){","){\n")).replace(/}$/g,"\n}")).split("\n");s.pop();let o=s.shift();s=s.join("\n");let t=o.match(/\([^)]*\)/)[0];return t=t.replace("(","").replace(")","").split(","),Function(...t,s)}function recurseSection({vertices:e,absoluteIndex:s},o=1){for(let t=0;t<o;t++)for(let o=e.length-6;o>-1;o-=6)recursivelyGenerate.call(this,o+s)}function recursivelyGenerate(e){if(e%6)throw new Error("The given vertex does not represent the start of a cell");if(!this.vertices[e])return void console.warn(`Skipping recursion: Index ${e} exceeds bounds (${this.vertices.length})`);const s=this.vertices.slice(e,e+6),o=this.vertices[e].recursions+1;let t=getSubSquares.call(this,{vertices:s,recursions:o,vertexIndex:e});this.vertices.splice(e,6,...t)}function getSubSquares(e){const{recursions:s}=e,[o,t,n,r,p,i]=e.vertices;let l=bilinearInterpolation({p1:o,p2:t,p3:n,p4:i});const a=vertexGenerator(s),c=[{pos:[l.x,l.y,l.z],...a.next().value},{pos:[i.pos[0],(i.pos[1]+t.pos[1])/2,l.z],...a.next().value},{pos:[l.x,(i.pos[1]+n.pos[1])/2,i.pos[2]],...a.next().value},{pos:[l.x,(i.pos[1]+n.pos[1])/2,i.pos[2]],...a.next().value},{pos:[i.pos[0],(i.pos[1]+t.pos[1])/2,l.z],...a.next().value},{...i,...a.next().value},{pos:[n.pos[0],(n.pos[1]+o.pos[1])/2,l.z],...a.next().value},{pos:[l.x,l.y,l.z],...a.next().value},{...n,...a.next().value},{...n,...a.next().value},{pos:[l.x,l.y,l.z],...a.next().value},{pos:[l.x,(i.pos[1]+n.pos[1])/2,n.pos[2]],...a.next().value},{pos:[l.x,(t.pos[1]+o.pos[1])/2,t.pos[2]],...a.next().value},{...t,...a.next().value},{pos:[l.x,l.y,l.z],...a.next().value},{pos:[l.x,l.y,l.z],...a.next().value},{...t,...a.next().value},{pos:[i.pos[0],(i.pos[1]+t.pos[1])/2,l.z],...a.next().value},{...o,...a.next().value},{pos:[l.x,(t.pos[1]+o.pos[1])/2,t.pos[2]],...a.next().value},{pos:[n.pos[0],(n.pos[1]+o.pos[1])/2,l.z],...a.next().value},{pos:[n.pos[0],(n.pos[1]+o.pos[1])/2,l.z],...a.next().value},{pos:[l.x,(t.pos[1]+o.pos[1])/2,t.pos[2]],...a.next().value},{pos:[l.x,l.y,l.z],...a.next().value}];return l=this.generators[this.generatorSelector({topLeft:i,topRight:n,bottomLeft:t,bottomRight:o,vertexIndex:e.vertexIndex})].call(this,c,c.map((e=>this.state.simplex.noise2D(e.pos[0]/this.genParams.noiseSampleCoeff,e.pos[2]/this.genParams.noiseSampleCoeff)))),c}function bilinearInterpolation(e){const{p1:s,p2:o,p3:t,p4:n,isCentroid:r=!0}=e;if(r)return{x:(s.pos[0]+o.pos[0]+t.pos[0]+n.pos[0])/4,y:(s.pos[1]+o.pos[1]+t.pos[1]+n.pos[1])/4,z:(s.pos[2]+o.pos[2]+t.pos[2]+n.pos[2])/4};throw new Error("Oops, someone had better implement non-centroid bilinear interpolation")}self.addEventListener("message",(({data:e})=>{if("recurseSection"===e.action){const s={colors:e.colors,waterLevel:e.waterLevel,vertices:e.section.vertices,genParams:e.genParams,generators:e.generators.map((e=>reconstructFunction(e))),generatorSelector:reconstructFunction(e.generatorSelector)};simplex||(simplex=new SimplexNoise(e.seed||Math.random().toString()),s.state={simplex});const o=e.levels||1;recurseSection.call(s,e.section,o),postMessage({vertices:s.vertices})}}));const vertexGenerator=function*(e){for(;;)yield{norm:[0,1,0],uv:[0,1],recursions:e},yield{norm:[0,1,0],uv:[1,1],recursions:e},yield{norm:[0,1,0],uv:[0,0],recursions:e},yield{norm:[0,1,0],uv:[0,0],recursions:e},yield{norm:[0,1,0],uv:[1,1],recursions:e},yield{norm:[0,1,0],uv:[1,0],recursions:e}};